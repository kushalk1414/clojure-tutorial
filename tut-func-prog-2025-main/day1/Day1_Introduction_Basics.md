# Day 1: Introduction & Basics

## Objectives
- Understand the fundamentals of functional programming
- Get familiar with Clojure syntax and environment
- Learn key principles of FP

---

## Topics Covered
- What is functional programming?
- Why use Clojure?
- Setting up the Clojure environment (REPL, editor, tools)
- Basic Clojure syntax (expressions, literals, functions)
- Functional programming principles (immutability, pure functions)

---

## Presentation Outline
1. **Introduction to Functional Programming**
   - Definition and core ideas
   - Comparison with object-oriented programming
   - Benefits and use cases
2. **Why Clojure?**
   - Brief history
   - Features and advantages
   - Clojure in the industry
3. **Environment Setup**
   - Installing Clojure
   - Using the REPL
   - Recommended editors and plugins
4. **Basic Syntax**
   - Expressions and evaluation
   - Data types: numbers, strings, keywords, symbols
   - Defining and calling functions
5. **Key FP Principles**
   - Immutability
   - Pure functions
   - Simple examples

---

## Exercises
- Install Clojure and run the REPL
- Write simple expressions and evaluate them
- Define basic functions
- Identify pure vs. impure functions
- Explore immutability with simple data structures

---

## Resources
- [Clojure Official Documentation](https://clojure.org/)
- [Clojure REPL Guide](https://clojure.org/guides/repl)
- [Functional Programming Concepts](https://en.wikipedia.org/wiki/Functional_programming)

---

## Notes
- Encourage hands-on experimentation in the REPL
- Focus on understanding concepts, not memorizing syntax
- Use simple, relatable examples

## Slides
### Disclaimer regarding AI
- Emphasize that AI is a tool, not a replacement for understanding
- Tell the model to only use functions you already understand
- Other than that, it is up to you to decide whether you want to use AI or not
### Introduction to Functional Programming
- Definition: A programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state
- Core ideas: First-class functions, higher-order functions, immutability
- Comparison with OOP: Emphasis on data and functions rather than objects and state
- Small amount of data strurtures, have many functions that operate on them
- Benefits: Easier reasoning about code, better modularity, easier testing
- Use cases: Data processing, concurrent programming, web development
- Clojure's role in the FP ecosystem
- Clojure's focus on simplicity and expressiveness
- Clojure as a Lisp dialect
- Clojure's immutability by default
- LISP syntax and its advantages
- The REPL as a powerful tool for interactive development